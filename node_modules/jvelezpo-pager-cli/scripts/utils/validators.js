'use strict';

const existsSync = require('command-exists').sync;

exports.validateNamespace = (namespace) => {
//   let [tenant, env] = namespace.split('-')

    //   const tenants = {
    //     pager: ['p', 'pgr', 'pager'],
    //     hrz: ['h', 'hrz', 'hzn', 'horizon']
    //   }
    //   const envs = {
    //     qa: ['dev', 'qa'],
    //     stage: ['stage', 'staging'],
    //     sdx: ['sdx', 'sandbox']
    //   }

    //   tenant = (Object.entries(tenants)).map(([tenN, variations]) => variations.includes(tenant) ? tenN : null).filter((t) => !!t)[0]
    //   env = (Object.entries(envs)).map(([envN, variations]) => variations.includes(env) ? envN : null).filter((e) => !!e)[0]

    //   if (!tenant || !env) {
    //     throw new Error(`invalid namespace, must be one of: {p,pgr,pager|h,hrz,hzn,horizon}-{dev,qa,st,stage,staging,sdx,sandbox}
    //           e.g. pager-qa
    //           e.g. hzn-staging`)
    //   }

    //   if (namespace === 'pgr-qa') return 'dev'
    //   return `${tenant}-${env}`
    return namespace;
};

exports.validateDb = (db) => {

    const dbs = {
        'mongodb-replicaset': ['m', 'mdb', 'mongo', 'mongodb'],
        postgresql: ['pg', 'postgres', 'postgresql']
    };

    db = (Object.entries(dbs)).map(([dbN, variations]) => (variations.includes(db) ? dbN : null)).filter((d) => !!d)[0];

    // validate db name if provided
    if (!db) {
        throw new Error('invalid db, must be one of: {mdb,mongo,mongodb|pg,postgres}');
    }

    return db;
};

exports.validatePort = (port) => {

    // TODO: doesn't validate whether port's in use, will error out if so while runnning kubectl commands
    port = parseInt(port);

    if (!Number.isInteger(port) || port < 1025 || port > 65535) {
        throw new Error('invalid port, must be a number between 1024-65536');
    }

    return port || 22222;
};

exports.validateCommandExists = (cmd) => {

    if (!existsSync(cmd)) {
        throw new Error(`command '${cmd}' not installed or not found in PATH`);
    }

    return true;
};
