'use strict';

const path = require('path');
const Fs = require('fs');
const util = require('util');
const chalk = require('chalk');
const indentString = require('indent-string');

const exec = util.promisify(require('child_process').exec);

const newRelicAccountIds = {
    1759850: 'Aptible Horizon',
    929602: 'Aptible Pager & Parent Account',
    2510975: 'GCP sra-prod',
    2825288: 'GCP cox-prod',
    2825336: 'GCP pgr-stage',
    2825335: 'GCP hrz-stage',
    2825337: 'GCP LL mixed'
};

class BackendStandardsChecker {
    constructor(dir) {

        this.dir = dir;
        this.eslintContent = require(path.join(this.dir, '.eslintrc.js'));
        this.readmeContent = Fs.readFileSync(path.join(this.dir, 'README.md'), 'utf-8').toString();
    }

    checkNoJenkinsfile() {

        let errorMessage;

        if (Fs.existsSync(path.join(this.dir, 'Jenkinsfile'))) {
            errorMessage = 'There should not be a Jenkinsfile';
        }

        return [!errorMessage, errorMessage];
    }

    checkNoConsole() {

        let errorMessage = '';

        try {
            if (!(this.eslintContent.rules && this.eslintContent.rules['no-console'])) {
                errorMessage = 'eslintrc no-console rule is not enabled';
            }
        }
        catch (e) {
            errorMessage = e.toString();
        }

        return [!errorMessage, errorMessage];
    }

    checkEslintHapi() {

        let errorMessage = '';

        try {
            if (this.eslintContent.extends !== '@hapi/eslint-config-hapi') {
                errorMessage = 'eslintrc does not extend @hapi/eslint-config-hapi';
            }
        }
        catch (e) {
            errorMessage = e.toString();
        }

        return [!errorMessage, errorMessage];
    }

    checkNewRelicLinks() {

        let match;
        let errorMessage = '';
        let missingEnvs = Object.values(newRelicAccountIds);

        const re = /https:\/\/rpm.newrelic.com\/accounts\/(\d+)\//g;
        while (match = re.exec(this.readmeContent)) {
            const envId = match[1];
            missingEnvs = missingEnvs.filter((env) => env !== newRelicAccountIds[envId]);
        }

        if (missingEnvs.length > 0) {
            errorMessage = 'Missing New Relic README links for enviroments:\n';
            errorMessage += indentString(missingEnvs.join('\n'), 4);
        }

        return [!errorMessage, errorMessage];
    }

    checkSentryLink() {

        let errorMessage = '';

        if (!this.readmeContent.includes('sentry.pager.com')) {
            errorMessage = 'Missing Sentry link in README';
        }

        return [!errorMessage, errorMessage];
    }

    async checkNoLocalhost() {

        let errorMessage;

        try {
            const { stdout } = await exec('ag -l --ignore-dir=node_modules localhost');

            if (stdout.length > 0) {
                errorMessage = 'Found localhost references in the following files:\n';
                errorMessage += indentString(stdout, 4);
            }
        }
        catch (e) {
            if (e.stderr && e.stderr.length > 0) {
                console.log(chalk.yellow('Please install silver searcher: brew install the_silver_searcher'));
            }
        }

        return [!errorMessage, errorMessage];
    }

    async complies() {

        let compliesAll = true;

        const checkResults = await Promise.all([
            this.checkNoJenkinsfile(),
            this.checkNoConsole(),
            this.checkEslintHapi(),
            this.checkNewRelicLinks(),
            this.checkSentryLink(),
            this.checkNoLocalhost()
        ]);

        checkResults.forEach(([valid, errorMessage]) => {

            if (!valid) {
                compliesAll = false;
                console.error(chalk.red(errorMessage));
            }
        });

        return compliesAll;
    }
}

module.exports = BackendStandardsChecker;
